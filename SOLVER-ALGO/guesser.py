# Author: Iason Chaimalas
# Date: 2 June 2022



from HashTableWordle import HashTableWordle # import class for hash table
from word_colour_pattern import int_to_ternary, ternary_to_int, read_list
from numpy import log2, random # log2 for entropy, random.randint for random nums
import json # for hash table read/write
import os
import time
from tqdm import tqdm as ProgressBarLookup # to see the progress of the lookup creation
import matplotlib.pyplot as plt
import statistics

class Guesser(HashTableWordle):
    """
    Process to guess the optimal word to find the Wordle solution word 
    
    Process: Lookup table gives guessmap (int 0-242) for every possible trueword
    given each guessword. The ideal guessmap is all-green, i.e. 0.
    For a single guessword, we get the mean guessmap value when this guessword
    is applied to ALL possible truewords. The guessword with the lowest mean
    guessmap (closest to 0) is the system's guess. Then, this guessword yields an
    actual guessmap when applied to the actual trueword in this specific Wordle
    game. This guessmap plus the guessword identifies the new list of possible
    truewords. Then, find the mean guessmap for each guessword applied to the smaller
    set of possible truewords (only use guesswords that can be the solution).
    Repeat until there is 1 possible trueword and then guess the trueword.
    This solves Wordle!

    """

    def __init__(self, solution_words):
        """ Constructor """

        super().__init__() # inherit constructor of HashTableWordle

        self.read_json('hashfile_wordkey') # read hashfile.json into the hash_table attr of Guesser
        
        # set up extra attr
        self.guess_counter = 0 # how many guesses the bot has already made
        self.current_guess = "" # current guess (initially empty) at guess_counter + 1 step
        self.poss = solution_words
            # the existing list of possible Wordle words generated by a 
            # previous call of this func for a different guessword
            # --> initially all solution_words are possible true solutions

    # narrows down possibilities for solution word given the resulting colourmap of 
    # the guessed word from func make_guess above
    def possibilities(self, guessword, guessmap, solution_words):
        """
        Inputs:
        -   guessword: current str guess
        -   guessmap: base-10 int representing the ternary list with 
            5 elements, each 2 (grey), 1 (yellow) or 0 (green) in value, which
            is the colourpattern for the given guess
        -   solution_words: list of all str possible solution words
        
        This func determines the possible correct Wordle words that fit the colour
        pattern for the given guessword.

        """

        if self.guess_counter == 0: # 1st guess -- 0 guesses already made
            self.poss = solution_words # 1st guess so solution word has not been narrowed down
        else:
            guesstrue = self.search_value(guessmap) # list of tuples that fit this guessmap
            
            poss_update = [] # initialised empty list which will be the new self.poss list
            
            all_guesswords_w_this_guessmap = list(map(lambda i: i[0], guesstrue))
                # extract guesswords
            all_truewords_w_this_guessmap = list(map(lambda i: i[1], guesstrue))
                # extract truewords

            for i in range(len(all_guesswords_w_this_guessmap)):
                if all_guesswords_w_this_guessmap[i] == guessword and all_truewords_w_this_guessmap[i] in self.poss:
                    # truewords which are associated with the guessword used in the current iteration, and which are
                    # in prev-iteration self.poss list of possible truewords, are current iteration possible truewords
                    poss_update.append(all_truewords_w_this_guessmap[i])
            
            self.poss = poss_update # update possible truewords list by only selecting the truewords from the past list
                # which are assoc w the guessword used and which fit the guessmap of the current guess

    # finds guess with max entropy and guesses it
    def make_guess(self, allowed_words):
        """
        Calculate the mean guessmap for each guessword applied to all possible 
        (poss) truewords and thus select the guessword with the minimum mean, 
        i.e. maximum entropy (gives most amount of information to narrow down 
        the possible solutions)

        """

        mean = [] # list for mean guessmap of each guessword applied to all poss

        for guessx in self.poss: # for all guesswords
            meanx = []
            for truex in self.poss:
                guessmapx = self.hash_table[f"{guessx},{truex}"]
                meanx.append(guessmapx)
            mean.append(sum(meanx)/len(meanx))

        minmean_guessindex = mean.index(min(mean))

        self.current_guess = self.poss[minmean_guessindex]
            # thus the current guess is the word corresponding to max entropy
            # i.e. the word that will give the most info on average
            # i.e. guessword with minimum guessmap mean

        self.guess_counter += 1 # increment as we have now made a guess

    def guess_for_one_true(self):
        """ If only one word remains as a possible trueword, make that guess """

        self.current_guess = self.poss # make final guess (self.poss has len = 1)
        self.guess_counter += 1

def valid_int_in(diglen, minint, maxint, msg):
    """
    Exception Handling function

    Accepts integer where each digit must be in the range [minint, maxint].
    The number of digits in the int input must be diglen.

    """

    inputflag = True # flag True runs While loop, set False if input is valid
    while inputflag:
        digitflag = True # True if all digits are within range

        try: # handle exceptions - try-except
            valin = input(f"\t{msg} >> ") # input prompt with message msg

            int(valin) # check that valin is a str integer

            if len(valin) != diglen: # check diglen condition
                print(f"The colourmap must have {diglen} digits\n")
                # do not set flag False -> rerun While loop
                continue # go to next while loop by triggering continue
            for i in valin:
                # checks that EACH digit is in range
                if ((int(i) < minint or int(i) > maxint)):
                    print(f"{i} option must be in range [{minint}, {maxint}]\n")
                        # find options outside range - do not make flag False
                    digitflag = False # digits not in range - invalid input            
        except ValueError:
            print("All input digits must be integers\n")
        else: # execute if no exception or continue is triggered (i.e valid input)
            if digitflag == True: inputflag = False # valid input

    return list(map(lambda x: int(x), valin))

def valid_str_in(inlist, msg):
    """
    Exception Handling function

    Checks that a user input consists of non-numerical characters and is a 
    valid input string that exists within the given arg inlist of valid 
    guesses (iter). The message displayed at the input stage is msg (str).

    """
    
    inputflag = True # True while input invalid, declared False -> ends While loop
    while inputflag:
        try: # handle exceptions
            strin = input(f"\t{msg} >> ") # input prompt with message msg
            strin = strin.lower() # make lowercase

            inlist = list(map(lambda x: x.lower(), inlist))
                # make all str elements in inlist lowercase
                # thus, inputs with wrong capitalisation/case will not throw error

            if (strin.isalpha and strin in inlist):
                # fully non-numeric string and included in list of valid inputs
                inputflag = False
            elif (not strin.isalpha): # flag still True
                print("Enter a fully non-numeric string\n")
            elif (strin not in inlist): # flag still True
                print("String input is not in the set of accepted inputs\n")
        except: # handle all possible exceptions
            print("Enter a valid string non-numeric input\n")
    
    return strin # valid string output

def main(mode = "autosolve"):
    """
    Modes:
        "autosolve" -> solves wordle with a randomly selected word automatically.
        "manual" -> takes user input of guesses made and resultant guessmap,
            and recommends guesses.
        "sim" -> simulates Wordle Guesser with all possible truewords.
            Plays 2315 games and records how many guesses it needed to solve each game.

    """

    # initialise paths for allowed and solution words
    txtpath = os.path.join(
        os.path.dirname(os.path.realpath(__file__)), "Words"
    )

    ALLOWED_WORDS_FILE = os.path.join(txtpath, "AllowedWords.txt")
    SOLUTION_WORDS_FILE = os.path.join(txtpath, "SolutionWord.txt")

    allowed_words = read_list(0)
    solution_words = read_list(1)
    
    # initialise Wordle Solver using Entropy
    guesswordle = Guesser(solution_words)

    if mode == "autosolve":
        # Choose a random solution word
        randindex = random.randint(0, len(solution_words))
        print(f"randindex = {randindex}")
        randsol = solution_words[randindex]
        print(f"randsol = {randsol}")
            # solution word at randomly-chosen index in solution-words list

        start = time.time()
        while guesswordle.current_guess != randsol:
            # while bot has not solved this Wordle yet
            # i.e. the result of the bot's guess is not the true solution

            if len(guesswordle.poss) > 1:
                guesswordle.make_guess(allowed_words) 
                    # make a guess

                guessx = guesswordle.current_guess

                guessmap = guesswordle.search_words((guessx, randsol))
                    # resultant guessmap of that guess (given the actual solution)

                guesswordle.possibilities(guessx, guessmap, solution_words)
                    # reconsider list of possible truewords based on observed guessmap

                print(f"Current Guess: {guessx}")
                print(f"Guessmap for this guess: {int_to_ternary(guessmap)}")
                
                print(f"Current Possibilities: {len(guesswordle.poss)}")
                if len(guesswordle.poss) < 100: print(guesswordle.poss)
            else:
                guesswordle.guess_for_one_true()
                print(f"Final Guess: {guesswordle.current_guess}")
                break
                # wordle solved
        end = time.time()    

        print(f"Wordle won in {guesswordle.guess_counter} guesses at {end-start} seconds!")
    
    elif mode == "manual":
        solvedwordle = False
        while not solvedwordle: # wordle not solved
            guesswordle.make_guess(allowed_words)
            proposed_guess = guesswordle.current_guess
            print(f"Bot recommends: {proposed_guess}")
            userguess = valid_str_in(allowed_words, "Enter your guess") # user enters their guess
            guessmap_tern = valid_int_in(5, 0, 2, "Enter your guess's guessmap as a ternary number")
            guessmap = ternary_to_int(guessmap_tern)
            guesswordle.possibilities(userguess, guessmap, solution_words)
                # reconsider list of possible truewords based on observed guessmap

            if guessmap == 0:
                solvedwordle = True # all green -> wordle solved
    
    elif mode == "sim":
        start = time.time()
        
        with open('GuesserSimulation.txt', 'w') as file:
            file.write("[")
            # this empties the file and starts a new list preceded with [
        
        guess_num = [] # list holding number of guesses needed to solve each trueword
        progress_sol = ProgressBarLookup(solution_words) #
        for truexsim in progress_sol:
            while guesswordle.current_guess != truexsim:
            # while bot has not solved this Wordle yet
            # i.e. the result of the bot's guess is not the true solution

                if len(guesswordle.poss) > 1:
                    guesswordle.make_guess(allowed_words) 
                        # make a guess
                    guessx = guesswordle.current_guess
                    guessmap = guesswordle.search_words((guessx, truexsim))
                        # resultant guessmap of that guess (given the actual solution)
                    guesswordle.possibilities(guessx, guessmap, solution_words)
                        # reconsider list of possible truewords based on observed guessmap
                else:
                    guesswordle.guess_for_one_true()
                    break
                    # wordle solved

            guess_num.append(guesswordle.guess_counter)
            if len(guess_num) >= len(solution_words)/463:
                # every 5 wordle games, the data is saved to file so if programme crashes midway most 
                # data is saved. 5 chosen because it evenly divides 2315
                with open('GuesserSimulation.txt', 'a') as file:
                    # within list, so no [ ], but only comma delimiter w next guess_counter elements
                    file.write(str(guess_num)[1:-1] + ', ') 
                        # save the list excluding brackets [] and add comma delimiter from next 5-element batch
                guess_num.clear() # clear list for next batch of 5 to save to list

            # re-initialise for next iteration:
            guesswordle.guess_counter = 0
            guesswordle.current_guess = ""
            guesswordle.poss = solution_words
        
        with open('GuesserSimulation.txt', 'a') as file:
            # end of list so end with ]
            file.truncate(file.tell() - 1) # deletes last comma so the list can end correctly with ]
            file.write(']')

        end = time.time()

        print(f"Time for simulation: {end - start}")
        
        with open('GuesserSimulation.txt', 'r') as file:
            guess_num_sim = json.loads(file.read())

        # Histogram of number of guesses to solve each of 2315 possible Wordle games
        plt.hist(guess_num_sim, 7)
        plt.title("Wordle Simulation with Guessmap Mean Minimisation Approach")
        plt.xlabel("Guess Number")
        plt.ylabel("Frequency")
        plt.savefig('hist_guesser.png')
        print("File hist_guesser.png saved")

        print(f"Mean Guess Number: {statistics.mean(guess_num_sim)}")
        print(f"Guess Standard Deviation: {statistics.stdev(guess_num_sim)}")

    else:
        raise Exception("Input Argument Error")

if __name__ == "__main__":
    main("manual") # called with either autosolve, manual, sim modes to play Wordle
